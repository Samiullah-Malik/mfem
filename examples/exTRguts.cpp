//                       MFEM Example 9 - Parallel Version//// Compile with: make ex9p//// Sample runs://    mpirun -np 4 ex9p -m ../data/periodic-segment.mesh -p 0 -dt 0.005//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/amr-quad.mesh -p 1 -rp 1 -dt 0.002 -tf 9//    mpirun -np 4 ex9p -m ../data/star-q3.mesh -p 1 -rp 1 -dt 0.004 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 1 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 2 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 3 -rp 2 -dt 0.0025 -tf 9 -vs 20//    mpirun -np 4 ex9p -m ../data/periodic-cube.mesh -p 0 -o 2 -rp 1 -dt 0.01 -tf 8////    MFEM_adv steady-state test runs//    1D currently not implemented.//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 5 -s 1 -col 1//    2D//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 5 -s 1 -col 1//    2D AMR//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 5 -s 1 -col 1//    High azimuthal resolution test.//    mpirun -np 4 ex23TRp -m ../data/inline-segment.mesh -p 0 -rp 0 -tf 2000000 -dt 1000 -s 1 -col 5 -sna 12//    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 0 -tf 2000000 -dt 100000 -s 1 -col 5 -sna 12//    mpirun -np 4 ex23TRp -m ../data/amr-quad.mesh -p 0 -rp 0 -tf 2000000 -dt 2000000 -s 1 -col 5 -sna 12 //    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 0 -tf 0.3 -dt 0.01 -s 1 -col 5 -sna 5//    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 1 -tf 0.23 -dt 0.01 -s 1 -col 5 -sna 5     //    mpirun -np 2 exTRguts -m milan_data/ALE_quad.mesh -rs 1//    AWBS//    mpirun -n 4 exTRguts -m 'milan_data/ALE_quad.mesh' -rs 0 -sna 1 -Ngr 900 -s 13//    mpirun -n 4 exTRguts -m 'milan_data/ALE_quad.mesh' -rs 0 -sna 1 -Ngr 80 -s 24 ////    WEAK SCALING TEST//    mpirun -n 4 exTRguts -m '../data/inline-quad.mesh' -rs 2 -s 24 -vis -ne 1e24 -sna 8 -vini 1.0 -vfin 0.0 -Ngr 100//// Description:  This example code solves the time-dependent advection equation//               du/dt + v.grad(u) = 0, where v is a given fluid velocity, and//               u0(x)=u(0,x) is a given initial condition.////               The example demonstrates the use of Discontinuous Galerkin (DG)//               bilinear forms in MFEM (face integrators), the use of explicit//               ODE time integrators, the definition of periodic boundary//               conditions through periodic meshes, as well as the use of GLVis//               for persistent visualization of a time-evolving solution. The//               saving of time-dependent data files for external visualization//               with VisIt (visit.llnl.gov) is also illustrated.// This problem seems to like an FFC rekaxation...#include "mfem.hpp"#include <fstream>#include <iostream>using namespace std;using namespace mfem;namespace TRguts{// Boltzmann constant.const double kB = 1.6022e-12; // [cgs, eV]// Electron mass.const double me = 9.1094e-28; // [cgs]// Pi.const double pi = atan(1.0)*4.0;// Collision frequency cross section.const double sigma = 8.1027575e17; // Matching the SH diffusive flux.// TMP values.double Te0 = 1.23e3;double ne_ref = 1.0e28; //1.0 / 8.1027575e17;double Z0 = 1.0;double zeta = 2.0;// Angles for discretization of velocity space.double ttheta = 0.0;double pphi = 0.0;// Tolerance to solve linear system todouble solve_tol;int use_gmres;int myid;// Direction coefficientvoid direction_func(const Vector &x, Vector &v);// E field projection to direction coefficient.double ndotE_func(const Vector &x);// Thermal velocity coefficient.double vth_func(const Vector &x);// Inflow boundary condition//double inflow_function(const Vector &x);// BGK related collision cross section.double rBneGamma_therm_func(const Vector &x);double rBneGamma_scat_func(const Vector &x);// AWBS related collision cross section.double neGammaHalf_therm_func(const Vector &x);double neGammaHalf_scat_func(const Vector &x);// Global value of current velocity to be used for source evaluation.double velocity_glob = 1.0;// Source of particlesdouble dfMdv_func(const Vector &x);// AWBS deceleration friction - E field projection to direction.double nue_ndotE_func(const Vector &x);double Q_BGK_func(const Vector &x);double Q_AWBS_func(const Vector &x);// Mesh bounding boxVector bb_min, bb_max;// Maximum number of scattering iterations.int scat_it_max = 20;double init_value = 0e-20;// Inflow boundary condition.double inflow_function(const Vector &x);struct AIR_parameters {   // Options: LAIR: {1, 1.5, 2}, NAIR: {3, 4, 5} - default 1.5   //    LAIR is more robust on non-triangular matrices, NAIR should be   //    faster to setup at the cost of slightly degraded convergence.    //    E.g., NAIR 4 corresponds to distance 4-2=2 restriction.   double distance;   // Options string consisting of F, C, or A; e.g., "FFC" or "FA"   //    Default: prerelax = "", postrelax = "FA" (FA specifically   //    for type 10 relax)   std::string prerelax;   std::string postrelax;   // Strength tolerance for coarsening. Default 0.1, can be problem   // dependent. Try between 0.01 and 0.5, typically in the middle.   double strength_tolC;   // Tolerance for building restriction. Smaller is better, typically    // 0.01 (default) or so.    double strength_tolR;   // Remove small entries from R. Default 0, strategy we are testing to   // reduce complexity.    double filter_tolR;   // Default 100 (simple interpolation). Can also use 6 (classical interp).   int interp_type;   // Default 10 (processor block Jacobi, i.e., ordered on processor Gauss-   // Seidel). Can also use 0 (Jacobi) or 3 (on processor, unordered Gauss-   // Seidel)   int relax_type;   // Eliminate small entries from the matrix to reduce memory/complexity.   // Default 1e-4. Can degrade convergence, if so make smaller.   double filterA_tol;   // Default 6, coarsens not aggressively. Can also use 3 (slower in    // parallel, also not aggressive coarsening) or 10 (more aggressive   // coarsening).   int coarsening;};void print_AIR(AIR_parameters AIR) {   std::cout << "Distance R:   " << AIR.distance << "\n" \             << "Prerelax:     " << AIR.prerelax << "\n" \             << "Postrelax:    " << AIR.postrelax << "\n" \             << "Strength C:   " << AIR.strength_tolC << "\n" \             << "Strength R:   " << AIR.strength_tolR << "\n" \             << "Interp type:  " << AIR.interp_type << "\n" \             << "Relax type:   " << AIR.relax_type << "\n" \             << "Coarsen type: " << AIR.coarsening << "\n" \             << "Filter tol:   " << AIR.filterA_tol << ".\n";}struct TimingData{   // Total times for all major computations:   // CG solves (H1 and L2) / force RHS assemblies / quadrature computations.   StopWatch sw_hypreMassMatrixSetup, sw_hypreTMatrixSetup,             sw_pAIRMatrixScale, sw_pAIRVectorScale, sw_pAIRSetup,              sw_pAIRSolve;   // These accumulate the total processed dofs or quad points:   // #(CG iterations) for the H1 CG solve.   // #dofs  * #(CG iterations) for the L2 CG solve.   // #quads * #(RK sub steps) for the quadrature data computations.   int pAIR_iter;   TimingData() : pAIR_iter(0) { }};/** A time-dependent operator for the right-hand side of the ODE. The DG weak    form of du/dt = -v.grad(u) + sigma (q - u) is M du/dt = K u + b, where M     and K are the mass and the advection minus the absorption matrices, and b     describes the volumetric source and the flow on the boundary. This can be     written as a general ODE, du/dt = M^{-1} (K u + b), and this class     is used to evaluate the right-hand side. */class FE_Evolution : public TimeDependentOperator{private:    HypreParMatrix &Maux;   const Array<HypreParMatrix*> &Ms, &MEs, &Ks;   //HypreParMatrix *T;   // For each SN direction d we solve T_d = M - dt (K_d - Ma);   HypreSmoother M_prec;   mutable CGSolver M_solver;   /* Precond/Solver for T */   //HypreBoomerAMG *AMG_solver;   //HypreGMRES     *GMRES_solver;   /* scaled version of T and z */   //HypreParMatrix T_s;   ParFiniteElementSpace &fes;   mutable Vector z;   double current_dt;   int SN;   const Array<double> w;   int blocksize;   AIR_parameters AIR;   mutable TimingData timer;public:   FE_Evolution(ParFiniteElementSpace &_fes,                HypreParMatrix &_Maux,                const Array<HypreParMatrix*> &_Ms,                const Array<double> &_w,                const Array<HypreParMatrix*> &_MEs,                 const Array<HypreParMatrix*> &_Ks,                   const int order,                 const AIR_parameters *AIR_init=NULL);   virtual void Mult(const Vector &x, Vector &y) const;   /** Solve the Backward-Euler equation:        d = f(x + dt*d, t+dt), where u_t = f(x,t).       This is the only requirement for high-order SDIRK implicit integration.*/   virtual void ImplicitSolve(const double dt, const Vector &u, Vector &k);   void PrintTimingData(bool IamRoot) const   {      double my_rt[8], rt_max[8];       my_rt[0] = timer.sw_pAIRMatrixScale.RealTime();      my_rt[1] = timer.sw_pAIRVectorScale.RealTime();      my_rt[2] = timer.sw_pAIRSetup.RealTime();      my_rt[3] = timer.sw_pAIRSolve.RealTime();      my_rt[4] = my_rt[0] + my_rt[1] + my_rt[2] + my_rt[3];      my_rt[5] = timer.sw_hypreMassMatrixSetup.RealTime();      my_rt[6] = timer.sw_hypreTMatrixSetup.RealTime();      my_rt[7] = my_rt[5] + my_rt[6];      MPI_Reduce(my_rt, rt_max, 8, MPI_DOUBLE, MPI_MAX, 0, fes.GetComm());      const int Vsize = fes.GetVSize();      if (IamRoot)      {         int precision = 6;         cout.precision(precision);         cout << endl << "C7 Timing Data" << endl << endl;           cout << "pAir total number of iterations:                "               << timer.pAIR_iter << endl;          cout << "pAIR solve rate (megadofs x AMG_iterations / second): "            << 1e-6 * Vsize * timer.pAIR_iter / rt_max[3] << endl << endl;         cout << std::scientific;         cout << "pAIR  - T matrix scaling total time:  " << rt_max[0] << endl;         cout << "pAIR  - T vector scaling total time:  " << rt_max[1] << endl;         cout << "pAIR  - solver setup total time:      " << rt_max[2] << endl;         cout << "pAIR  - solve total time:             " << rt_max[3] << endl;         cout << "pAIR  - total time:                   " << rt_max[4] << endl;         cout << "nuE   - mass matrix setup total time: " << rt_max[5] << endl;         cout << "Hypre - T matrix setup total time:    " << rt_max[6] << endl;         //cout << "Hypre - total time:                   " << rt_max[7] << endl;      }   }   void Destroy()   {      BlockInvScal(NULL, NULL, NULL, NULL, 0, -1);      //if (T) delete T;      //if (AMG_solver) delete AMG_solver;      //if (GMRES_solver) delete GMRES_solver;   }   //virtual ~FE_Evolution() { }};int TRmain(ParMesh *pmesh, AIR_parameters AIR, double _ne_ref,            Vector &_bb_min, Vector &_bb_max,            int Ngr, int ode_solver_type=3, int SN_azi=4,            double vini=1.0, double vfin=0.0, int _scat_it_max=20,            bool visualization=false, int order=4){   // Assign reference density of plasma.   ne_ref = _ne_ref;   // Assign maximum number of scattering iterations.   scat_it_max = _scat_it_max;   // Assign computational domain boundaries.   bb_min = _bb_min;   bb_max = _bb_max;   // 1. Initialize MPI.   int num_procs;   num_procs = pmesh->GetNRanks();   myid = pmesh->GetMyRank();   // 2. Parse command-line options.   solve_tol = 1e-8;   use_gmres = 0;   int SN_pol = 1;   bool visit = false;   bool binary = false;   int vis_steps = 20;   int precision = 8;   cout.precision(precision);   //double h_min, h_max, k_min, k_max;   int dim = pmesh->Dimension();   // Get mesh size, set time step and solve tol accordingly, if specified   //pmesh->GetCharacteristics(h_min, h_max, k_min, k_max);   //if (dt < 0) dt = pow(h_max,- velocity_glob * dt);   //if (solve_tol < 0) {   //   solve_tol = dt;   //   if (myid == 0) std::cout << "Solve tolerance = dt = " << dt << "\n";   //}     // 4. Define the ODE solver used for time integration. Several explicit   //    Runge-Kutta methods are available.   ODESolver *ode_solver = NULL;   switch (ode_solver_type)   {      // Implicit L-stable methods      case 1:  ode_solver = new BackwardEulerSolver; break;      case 2:  ode_solver = new SDIRK23Solver(2); break;      case 3:  ode_solver = new SDIRK33Solver; break;      // Explicit methods      case 11: ode_solver = new ForwardEulerSolver; break;      case 12: ode_solver = new RK2Solver(0.5); break; // midpoint method      case 13: ode_solver = new RK3SSPSolver; break;      case 14: ode_solver = new RK4Solver; break;      // Implicit A-stable methods (not L-stable)      case 22: ode_solver = new ImplicitMidpointSolver; break;      case 23: ode_solver = new SDIRK23Solver; break;      case 24: ode_solver = new SDIRK34Solver; break;      default:         cout << "Unknown ODE solver type: " << ode_solver_type << '\n';         return 3;   }   // 7. Define the parallel discontinuous DG finite element space on the   //    parallel refined mesh of the given polynomial order.   DG_FECollection fec(order, dim);   ParFiniteElementSpace *fes = new ParFiniteElementSpace(pmesh, &fec);   HYPRE_Int global_vSize = fes->GlobalTrueVSize();   if (myid == 0) {      cout << "Number of unknowns: " << global_vSize << endl;      cout << "Block size: " << (order+1)*(order+1) << endl;   }   // 8. Set up and assemble the parallel bilinear and linear forms (and the   //    parallel hypre matrices) corresponding to the DG discretization. The   //    DGTraceIntegrator involves integrals over mesh interior faces.    // Coefficients to be used.   ConstantCoefficient zero_cf(0.0);   ConstantCoefficient one_cf(1.0);   FunctionCoefficient neGammaHalf_therm_cf(neGammaHalf_therm_func);   FunctionCoefficient neGammaHalf_scat_cf(neGammaHalf_scat_func);   FunctionCoefficient rBneGamma_therm_cf(rBneGamma_therm_func);   FunctionCoefficient rBneGamma_scat_cf(rBneGamma_scat_func);   VectorFunctionCoefficient direction(dim, direction_func);   FunctionCoefficient ndotE_cf(ndotE_func);   int skip_zeros = 0;   // Prepare an auxiliary zero mass matrix to be used to do "sum"   // of mass-block-diagonal Hypre matrices instead of expensive "add".   ParBilinearForm *maux = new ParBilinearForm(fes);   maux->AddDomainIntegrator(new MassIntegrator(zero_cf));   maux->Assemble(skip_zeros);   maux->Finalize(skip_zeros);   HypreParMatrix *Maux = maux->ParallelAssemble();   // Gather mass based bilinear forms (block-diagonal).   Array<ParBilinearForm*> ms;   // Add standart one mass matrix for time evolution.   // Index 0.   ParBilinearForm *mone = new ParBilinearForm(fes);   mone->AddDomainIntegrator(new MassIntegrator(one_cf));   mone->Assemble(skip_zeros);   mone->Finalize(skip_zeros);   ms.Append(mone);   // Add BGK thermalization mass matrix.   // Index 1.   ParBilinearForm *mth_BGK = new ParBilinearForm(fes);   mth_BGK->AddDomainIntegrator(new MassIntegrator(rBneGamma_therm_cf));   mth_BGK->Assemble(skip_zeros);   mth_BGK->Finalize(skip_zeros);   ms.Append(mth_BGK);   // Add BGK scattering mass matrix.   // Index 2.   ParBilinearForm *mscat_BGK = new ParBilinearForm(fes);   mscat_BGK->AddDomainIntegrator(new MassIntegrator(rBneGamma_scat_cf));   mscat_BGK->Assemble(skip_zeros);   mscat_BGK->Finalize(skip_zeros);   ms.Append(mscat_BGK);   // Add AWBS thermalization mass matrix.   // Index 3.   ParBilinearForm *mth_AWBS = new ParBilinearForm(fes);   mth_AWBS->AddDomainIntegrator(new MassIntegrator(neGammaHalf_therm_cf));   mth_AWBS->Assemble(skip_zeros);   mth_AWBS->Finalize(skip_zeros);   ms.Append(mth_AWBS);   // Add AWBS scattering mass matrix.   // Index 4.   ParBilinearForm *mscat_AWBS = new ParBilinearForm(fes);   mscat_AWBS->AddDomainIntegrator(new MassIntegrator(neGammaHalf_scat_cf));   mscat_AWBS->Assemble(skip_zeros);   mscat_AWBS->Finalize(skip_zeros);   ms.Append(mscat_AWBS);   // Special treatment of the angular dependent components.   // Advection matrix for each SN direction.    double dtheta = 2.0 * pi / double(SN_azi);   Array<ParBilinearForm*> ks;   Array<ParBilinearForm*> mEs;    Array<double> w;    for (int dp = 0; dp < SN_pol; dp++)   {      double wp = 2.0;      for (int da = 0; da < SN_azi; da++)      {         // Set azimuthal angle theta to define direction.          ttheta = da * dtheta;         //cout << "ttheta: " << ttheta << endl;         // Add advection matrix for given direction.         ParBilinearForm *k = new ParBilinearForm(fes);           k->AddDomainIntegrator(new ConvectionIntegrator(direction, -1.0));         k->AddInteriorFaceIntegrator(            new TransposeIntegrator(new DGTraceIntegrator(direction, 1.0, -0.5)));         k->AddBdrFaceIntegrator(            new TransposeIntegrator(new DGTraceIntegrator(direction, 1.0, -0.5)));         k->Assemble(skip_zeros);         k->Finalize(skip_zeros);         ks.Append(k);         // Add ndotE mass matrix for given direction.         ParBilinearForm *mE = new ParBilinearForm(fes);         mE->AddDomainIntegrator(new MassIntegrator(ndotE_cf));         mE->Assemble(skip_zeros);         mE->Finalize(skip_zeros);         mEs.Append(mE);         // Add appropriate weight related to direction d.         double wa = dtheta;         w.Append(wp * wa);      }   }   // Total number of SN directions.   int SN = ks.Size();   // Transalte bilinear forms to Hypre matrices.   // Particular mass matrices.   Array<HypreParMatrix*> Ms;   for (int i = 0; i < ms.Size(); i++)   {      Ms.Append(ms[i]->ParallelAssemble());   }   // Direction dependent matrices.   Array<HypreParMatrix*> Ks;   Array<HypreParMatrix*> MEs;   for (int d = 0; d < SN; d++)   {      Ks.Append(ks[d]->ParallelAssemble());      MEs.Append(mEs[d]->ParallelAssemble());   }   // 9. Define the initial conditions, save the corresponding grid function to   //    a file and (optionally) save data in the VisIt format and initialize   //    GLVis visualization.   // All directions psi are integrated in time as a system, we group them    // together in block vector Psi, on the unique parallel degrees of freedom,    // with offsets given by array true_offset.   int true_size = fes->TrueVSize();   Array<int> true_offset(SN+2); // SN + phi + closure.   for (int o = 0; o < SN+2; o++) { true_offset[o] = o * true_size; }   BlockVector Psi(true_offset);   // Grid functions of the SN directions.   Array<ParGridFunction *> psi_Agf;   for (int o = 0; o < SN; o++)    {       ParGridFunction *psi_pgf = new ParGridFunction(fes);       psi_pgf->MakeTRef(fes, Psi, true_offset[o]);      ConstantCoefficient cst_cf(init_value);      psi_pgf->ProjectCoefficient(cst_cf);      psi_pgf->SetTrueVector();      psi_pgf->SetFromTrueVector();      psi_Agf.Append(psi_pgf);   }   // Grid function of the scalar flux.   ParGridFunction phi_gf;   phi_gf.MakeTRef(fes, Psi, true_offset[SN]);   phi_gf = 0.0;   phi_gf.SetTrueVector();   phi_gf.SetFromTrueVector();   ParGridFunction int_phi_gf(fes);   int_phi_gf = 0.0;      {      ostringstream mesh_name, sol_name;      mesh_name << "ex23TR-mesh." << setfill('0') << setw(6) << myid;      sol_name << "ex23TR-init." << setfill('0') << setw(6) << myid;      ofstream omesh(mesh_name.str().c_str());      omesh.precision(precision);      pmesh->Print(omesh);      ofstream osol(sol_name.str().c_str());      osol.precision(precision);      phi_gf.Save(osol);   }   // Create data collection for solution output: either VisItDataCollection for   // ascii data files, or SidreDataCollection for binary data files.   DataCollection *dc = NULL;   if (visit)   {      if (binary)      {#ifdef MFEM_USE_SIDRE         dc = new SidreDataCollection("Example9-Parallel", pmesh);#else         MFEM_ABORT("Must build with MFEM_USE_SIDRE=YES for binary output.");#endif      }      else      {         dc = new VisItDataCollection("Example9-Parallel", pmesh);         dc->SetPrecision(precision);         // To save the mesh using MFEM's parallel mesh format:         // dc->SetFormat(DataCollection::PARALLEL_FORMAT);      }      dc->RegisterField("solution", &phi_gf);      dc->SetCycle(0);      dc->SetTime(0.0);      dc->Save();   }   socketstream sout;   if (visualization)   {      char vishost[] = "localhost";      int  visport   = 19916;      sout.open(vishost, visport);      if (!sout)      {         if (myid == 0)            cout << "Unable to connect to GLVis server at "                 << vishost << ':' << visport << endl;         visualization = false;         if (myid == 0)         {            cout << "GLVis visualization disabled.\n";         }      }      else      {         /*          sout << "parallel " << num_procs << " " << myid << "\n";         sout.precision(precision);         sout << "solution\n" << *pmesh << phi_gf;         sout << "pause\n";         sout << flush;         sout << "parallel " << num_procs << " " << myid << "\n";         sout.precision(precision);         sout << "solution\n" << *pmesh << *(psi_Agf[SN-1]);         sout << "pause\n";         sout << flush;         sout << "parallel " << num_procs << " " << myid << "\n";         sout.precision(precision);         sout << "solution\n" << *pmesh << int_phi_gf;         sout << "pause\n";         sout << flush;         */         if (myid == 0)            cout << "GLVis visualization paused."                 << " Press space (in the GLVis window) to resume it.\n";      }   }   // 10. Define the time-dependent evolution operator describing the ODE   //     right-hand side, and perform time-integration (looping over the time   //     iterations, ti, with a time-step dt).   FE_Evolution eltr(*fes, *Maux, Ms, w, MEs, Ks, order, &AIR);    // Find the maximum electron velocity.   ParGridFunction vth_gf(fes);   FunctionCoefficient vth_cf(vth_func);   vth_gf.ProjectCoefficient(vth_cf);   double loc_vth_max = vth_gf.Max(), glob_vth_max;   MPI_Allreduce(&loc_vth_max, &glob_vth_max, 1, MPI_DOUBLE, MPI_MAX,                 pmesh->GetComm());   double vth_mult = 7.0;   double velocity_max = vth_mult * glob_vth_max;      //cout << "velocity_max: " << velocity_max << endl << flush;   // Simulate velocity by time in AWBS frame.   double tfinal = vfin * velocity_max;   double tinit = vini * velocity_max;   // Velocity step negative because we decelerate electrons.   double dt = (tfinal - tinit) / Ngr;   double t = tinit;   eltr.SetTime(t);   ode_solver->Init(eltr);   bool done = false;   for (int ti = 0; !done; )   {      double dt_real = dt / abs(dt) * min(abs(dt), abs(tfinal - t));      //double dt_real = max(dt, t0 - t);      ode_solver->Step(Psi, t, dt_real);      ti++;      /*      // Handle the distribution function and their moments.         // Integration of phi.      for (int d = 0; d < SN; d++)      {         // Distribution function.         psi_Agf[d]->SetFromTrueVector();         // dn v^2 dv integration.         int_phi_gf.Add(w[d] * t * t * dt, *(psi_Agf[d]));      }      */            done = (abs(t - tfinal) <= 1e-8*abs(dt));      //done = (t <= t0 - 1e-8*dt);      if (done || ti % vis_steps == 0)      {         if (myid == 0)         {            cout << "time step: " << ti << ", time: " << t << endl;         }         // 11. Extract the parallel grid function corresponding to the finite         //     element approximation Psi (the local solution on each processor).         phi_gf.SetFromTrueVector();         // Respect direction of integration.         phi_gf *= (tfinal - tinit) / abs(tfinal - tinit);         // Scaling with respect to the ne_ref number of particles.         phi_gf *= 1.0 / ne_ref;         int_phi_gf = 0.0;         for (int d = 0; d < SN; d++)         {            // Distribution function.            psi_Agf[d]->SetFromTrueVector();            // dOmega integration.            int_phi_gf.Add(w[d], *(psi_Agf[d]));         }         if (visualization)         {            sout << "parallel " << num_procs << " " << myid << "\n";             sout << "solution\n" << *pmesh << phi_gf;            //sout << "pause\n";            //sout << flush;            //sout << "parallel " << num_procs << " " << myid << "\n";            //sout << "solution\n" << *pmesh << *(psi_Agf[SN-1]);            //sout << "pause\n";            //sout << flush;            /*            sout << "parallel " << num_procs << " " << myid << "\n";            sout << "solution\n" << *pmesh << int_phi_gf;            sout << "pause\n";            sout << flush;            */         }         if (visit)         {            dc->SetCycle(ti);            dc->SetTime(t);            dc->Save();         }      }   }   // 13. Free the used memory.   delete Maux;   delete maux;   for (int i = 0; i < ms.Size(); i++)    {       delete ms[i];      delete Ms[i];    }   for (int d = 0; d < SN; d++)   {      delete ks[d];      delete Ks[d];      delete mEs[d];      delete MEs[d];      delete psi_Agf[d];   }   delete fes;   delete ode_solver;   bool IamRoot = false;   if (myid == 0) IamRoot = true;   eltr.PrintTimingData(IamRoot);   eltr.Destroy();   return 0;}int TRmain(ParMesh *pmesh, Vector &_bb_min, Vector &_bb_max){   // Assign computational domain boundaries.   bb_min = _bb_min;   bb_max = _bb_max;   // 1. Initialize MPI.   int num_procs;   num_procs = pmesh->GetNRanks();   myid = pmesh->GetMyRank();   // 2. Parse command-line options.   solve_tol = 1e-8;   use_gmres = 0;   int order = 3;   int SN_pol = 1;   int SN_azi = 4;   //int SN_azi = 32.0;   // Number of equidistant velocity groups and dv;   int Ngr = 110;   double ne_ref = 1e28;   double vini = 1.0;   double vfin = 0.0;   int _scat_it_max = 20;   bool vis = true;   //int ode_solver_type = 1; // Implicit backward Euler.   int ode_solver_type = 3; //2; // Implicit SDIRK.   //int Ngr = 50;   //int ode_solver_type = 11; // Explicit forward Euler.   //int ode_solver_type = 14; // Explicit solve RK4.   //AIR_parameters AIR = {1.5, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 6};   AIR_parameters AIR = {2, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 10};   TRmain(pmesh, AIR, ne_ref, bb_min, bb_max,           Ngr, ode_solver_type, SN_azi, vini, vfin, _scat_it_max, vis, order);}// Implementation of class FE_EvolutionFE_Evolution::FE_Evolution(ParFiniteElementSpace &_fes,                            HypreParMatrix &_Maux,                           const Array<HypreParMatrix*> &_Ms,                           const Array<double> &_w,                           const Array<HypreParMatrix*> &_MEs,                           const Array<HypreParMatrix*> &_Ks,                            const int order,                           const AIR_parameters *AIR_init)   : TimeDependentOperator(_fes.GetVSize() * (_Ks.Size() + 1)), fes(_fes),                           Maux(_Maux), Ms(_Ms), MEs(_MEs), Ks(_Ks),                            w(_w), M_solver(_fes.GetComm()),                            z(_fes.GetVSize()), timer(){   // Explicit solver initialization.   M_prec.SetType(HypreSmoother::Jacobi);   M_solver.SetPreconditioner(M_prec);   M_solver.iterative_mode = false;   M_solver.SetRelTol(1e-9);   M_solver.SetAbsTol(0.0);   M_solver.SetMaxIter(100);   M_solver.SetPrintLevel(0);   // Number of SN directions.   SN = Ks.Size();   //T = NULL;   //AMG_solver = NULL;   //GMRES_solver = NULL;   if (AIR_init)    {      AIR = *AIR_init;      if (myid == 0) print_AIR(AIR);   }   // DG block size given by (FEorder+1)^2 on square meshes.   blocksize = (order+1)*(order+1);   // TEST @MH Check the mass matrices sparsity for Hypre.   //Maux = 0.0;   //Maux.Add(1.0, *(Ms[0])); // Same sparsity -> works!   //Maux.Add(1.0, *(Ks[1])); // Different sparcity -> does not work!}void FE_Evolution::Mult(const Vector &x, Vector &y) const{   // Set global velocity value to calculate all relevant terms with it.   //velocity_glob = 1.0;   velocity_glob = GetTime();   // The monolithic BlockVector stores the unknown fields as follows:   // (psi_1, .., psi_SN).   Vector* sptr = (Vector*) &x;   const int Vsize = fes.GetVSize();   Vector z_aux(Vsize);   ParGridFunction psix, psiy, dphi_dt;    // Assign grid function vector to phi after SN directions.   dphi_dt.MakeRef(&fes, y, SN * Vsize);   dphi_dt = 0.0;   // Assign BGK collision mass matrix.   //HypreParMatrix &MaBGK = *(Ms[1]);    // Assign AWBS collision mass matrix.   HypreParMatrix &MaAWBS = *(Ms[3]);      // Project grid function.   FunctionCoefficient dfMdv_cf(dfMdv_func);   ParGridFunction dfMdv_gf(&fes);   dfMdv_gf.ProjectCoefficient(dfMdv_cf);   // Set the rhs vector based on the source.   Vector b(Vsize);   MaAWBS.Mult(dfMdv_gf, b);   b *= 1.0 / pow(velocity_glob, 3.0);   // Set the system matrix.   Maux = 0.0;   Maux.Add(1.0 / pow(velocity_glob, 3.0), MaAWBS);   //Maux.Add(-1.0 / velocity_glob, ME);   M_solver.SetOperator(Maux);     // y = M^{-1} (K x + b)   for (int d = 0; d < SN; d++)   {      // Assign grid function vectors for given direction d.      psix.MakeRef(&fes, *sptr, d * Vsize);      psiy.MakeRef(&fes, y, d * Vsize);      // Assign advection matrix for given direction d.      HypreParMatrix &nGrad = *(Ks[d]);      // Assign standard Efield mass matrix.      HypreParMatrix &ME = *(MEs[d]);/*      nGrad.Mult(psix, z);      //MaBGK.Mult(psix, z_aux);      MaAWBS.Mult(psix, z_aux);      z -= z_aux;      z += b;      // Set the system matrix.      Maux = 0.0;      double velocity_ = 0.034;      Maux.Add(1.0 / velocity_, *(Ms[0]));      M_solver.SetOperator(Maux);      // Solve for dpsi_dt.      M_solver.Mult(z, psiy);*/      // Solve the AWBS equation:      //    n.Grad * u + n.E * du_dt = nu * (du_dt - dfM_dt)      //    K * u + ME * du_dt = Ma * (du_dt - dfM_dt)      //    K * (u + dudt*dt) + ME * du_dt = Ma * (du_dt - dfM_dt)      // by solving associated linear system      //    (Ma - ME) du_dt = K * u + Ma * dfM_dt      //    (Ma - ME - dt*K) du_dt = K * u + Ma * dfM_dt      nGrad.Mult(psix, z);      z += b;      // Solve for dpsi_dt.      M_solver.Mult(z, psiy);      //M_solver.Mult(b, psiy);      //psiy = dfMdv_gf;      // Contribution to the zero moment int_Omega int_v phi v^2 dv dOmega.       dphi_dt.Add(w[d], psix);      //dphi_dt.Add(w[d], psiy);   }   // Spherical coordinates velocity space metric.   // int_v int_Omega (phi+dphidt*dt) dOmega v^alpha dv.   //double alpha = 2.0; // Number of particles moment.     double alpha = 4.0; // Energy moment.   dphi_dt *= pow(velocity_glob, alpha);}void FE_Evolution::ImplicitSolve(const double dt, const Vector &u, Vector &du_dt){   // Set global velocity value to calculate all relevant terms with it.   //velocity_glob = 1.0;   velocity_glob = GetTime(); //+ 0.5 * dt;   // Playing with dv;   double dv = -dt;   current_dt = dt;   // The monolithic BlockVector stores the unknown fields as follows:   // (psi_1, .., psi_SN).   Vector* sptr = (Vector*) &u;   const int Vsize = fes.GetVSize();   Vector z_aux(Vsize);   ParGridFunction psi, dpsi_dt, dphi_dt;   ParGridFunction phi0(&fes), phi(&fes), dphi0(&fes), dphi(&fes);   // Angular integration of previous time step scalar flux phi0.   phi0 = 0.0;   double fourpi = 0.0;   for (int d = 0; d < SN; d++)   {      // Assign grid function vectors for given direction d.      psi.MakeRef(&fes, *sptr, d * Vsize);      phi0.Add(w[d], psi);      fourpi += w[d];   }   // Initial guess for scalar flux is the old value.   phi = phi0;    // Assign standard one-mass matrix and BGK and AWBS collision mass matrix.   //HypreParMatrix &Mone = *(Ms[0]);   //HypreParMatrix &MaBGK = *(Ms[1]);    HypreParMatrix &MaAWBS = *(Ms[3]);   HypreParMatrix &MscatAWBS = *(Ms[4]);   // Project grid function.   FunctionCoefficient dfMdv_cf(dfMdv_func);   ParGridFunction dfMdv_gf(&fes);   dfMdv_gf.ProjectCoefficient(dfMdv_cf);   // Set the rhs vector based on the source.   Vector b_dfMdv(Vsize);   MaAWBS.Mult(dfMdv_gf, b_dfMdv);   b_dfMdv *= 1.0 / pow(velocity_glob, 3.0);   // Solve the AWBS equation:   //    n.Grad * u + n.E * du_dt = nu * (du_dt - dfM_dt)   //    K * u + ME * du_dt = Ma * (du_dt - dfM_dt)   //    K * (u + dudt*dt) + ME * du_dt = Ma * (du_dt - dfM_dt)   // by solving associated linear system   //    (Ma - ME) du_dt = K * u + Ma * dfM_dt   //    (Ma - ME - dt*K) du_dt = K * u + Ma * dfM_dt         // Prepare the system matrix T and its scaled version Ts for all directions.   Array<HypreParMatrix*> T;   T.SetSize(SN);   Array<HypreParMatrix*> Ts;   Ts.SetSize(SN);   // TMP works for azimuthal discretization.   double dtheta = 2.0 * pi / double(SN);   for (int d = 0; d < SN; d++)   {      /*      // Assign standard Efield mass matrix.      HypreParMatrix &ME = *(MEs[d]);      // Do the sum of corresponding mass matrices.      timer.sw_hypreMassMatrixSetup.Start();      Maux = 0.0;      Maux.Add(1.0 / pow(velocity_glob, 3.0), MaAWBS);      Maux.Add(-1.0 / velocity_glob, ME);      Maux.Add(-dt / pow(velocity_glob, 4.0), MscatAWBS);      timer.sw_hypreMassMatrixSetup.Stop();      */      // Set azimuthal angle theta to define direction.       ttheta = d * dtheta;      // TESTING add boundary inflow equal to constant  initial value.      //int dim = fes.GetMesh()->Dimension();      //VectorFunctionCoefficient direction(dim, direction_func);      //FunctionCoefficient inflow(inflow_function);      //ParLinearForm bdr(&fes);      //bdr.AddBdrFaceIntegrator(      //   new BoundaryFlowIntegrator(inflow, direction, -1.0, -0.5));      //bdr.Assemble();      // Construct nue_ndotE mass matrix for given direction.      int skip_zeros = 0.0;            timer.sw_hypreMassMatrixSetup.Start();      FunctionCoefficient nue_ndotE_cf(nue_ndotE_func);      ParBilinearForm m_nuE(&fes);      m_nuE.AddDomainIntegrator(new MassIntegrator(nue_ndotE_cf));      m_nuE.Assemble(skip_zeros);      m_nuE.Finalize(skip_zeros);      HypreParMatrix *MnuE = m_nuE.ParallelAssemble();      Maux = 0.0;      Maux.Add(1.0, *MnuE);      Maux.Add(-dv / pow(velocity_glob, 4.0), MscatAWBS);      timer.sw_hypreMassMatrixSetup.Stop();      delete MnuE;      // Assign advection matrix for given direction d.      HypreParMatrix &nGrad = *(Ks[d]);      /* T is NULL, this should be the first solve with T,      * scale T, setup AMG and GMRES */      timer.sw_hypreTMatrixSetup.Start();      T[d] = HypreParMatrixAdd(1.0, Maux, -1.0*dv, nGrad);      timer.sw_hypreTMatrixSetup.Stop();       /* scale T by block-diagonal inverse */      timer.sw_pAIRMatrixScale.Start();       Ts[d] = new HypreParMatrix();      BlockInvScal(T[d], Ts[d], NULL, NULL, blocksize, 0);      timer.sw_pAIRMatrixScale.Stop();      //if (myid == 0) std::cout << "direction: " << d      //                         << " , assembled matrices: "       //                         << T[d]->GetNumRows() << ", " \      //                         << T[d]->GetNumCols() << ", "       //                         << T[d]->NNZ() << "\n";   }    // The scattering iteration added only artificially for now.    int pAIR_it = 0;    int scat_it = 0;   double loc_norm, glob_norm;    double res = 1.0, glob_norm0 = 0.0;   double scat_res_tol = 1e-10;   while ((res >= scat_res_tol) & (scat_it < scat_it_max))   {       scat_it++;       dphi = 0.0;      // Solve the AWBS equation:      //    n.Grad * u + n.E * du_dt = nu * (du_dt - dfM_dt)      //    K * u + ME * du_dt = Ma * (du_dt - dfM_dt)      //    K * (u + dudt*dt) + ME * du_dt = Ma * (du_dt - dfM_dt)      // by solving associated linear system      //    (Ma - ME) du_dt = K * u + Ma * dfM_dt      //    (Ma - ME - dt*K) du_dt = K * u + Ma * dfM_dt            for (int d = 0; d < SN; d++)      {         // Assign grid function vectors for given direction d.         psi.MakeRef(&fes, *sptr, d * Vsize);         dpsi_dt.MakeRef(&fes, du_dt, d * Vsize);         // Assign advection matrix for given direction d.         HypreParMatrix &nGrad = *(Ks[d]);         // Prepare pAIR solver.         timer.sw_pAIRSetup.Start();          HypreBoomerAMG AMG_solver(*(Ts[d]));          AMG_solver.SetLAIROptions(AIR.distance, AIR.prerelax,                                    AIR.postrelax, AIR.strength_tolC,                                    AIR.strength_tolR, AIR.filter_tolR,                                   AIR.interp_type, AIR.relax_type,                                    AIR.filterA_tol, AIR.coarsening);         timer.sw_pAIRSetup.Stop();         if (!use_gmres) {            //AMG_solver.SetPrintLevel(1);            AMG_solver.SetPrintLevel(0);            AMG_solver.SetTol(solve_tol);            AMG_solver.SetMaxIter(500);         }         else {            /*            HypreGMRES *GMRES_solver = new HypreGMRES(T_s);            GMRES_solver->SetAbsTol(solve_tol);            GMRES_solver->SetMaxIter(500);            GMRES_solver->SetPrintLevel(1);            GMRES_solver->SetPreconditioner(*AMG_solver_loc);            */            /* TODO zero init guess ? */            //GMRES_solver->SetZeroInintialIterate();            //GMRES_solver->iterative_mode = false;         }         MFEM_VERIFY(dt == current_dt, ""); // SDIRK methods use the same dt         // Prepare rhs.         Vector z_(Vsize), z_aux(Vsize);         nGrad.Mult(psi, z_);         z_ *= -1.0;         MscatAWBS.Mult(psi, z_aux);         z_aux *= 1.0 / pow(velocity_glob, 4.0);         z_aux *= -1.0;         z_ += z_aux;         MscatAWBS.Mult(phi, z_aux);         z_aux *= - 1.0 / fourpi / pow(velocity_glob, 4.0);         z_aux *= -1.0;         z_ += z_aux;         z_ += b_dfMdv;         // scale the rhs and solve system         HypreParVector z_s;         timer.sw_pAIRVectorScale.Start();         BlockInvScal(T[d], NULL, &z_, &z_s, blocksize, 2);         timer.sw_pAIRVectorScale.Stop();         if (use_gmres){            //GMRES_solver->Mult(z_s, dpsi_dt);         }         else {            // Previous step init guess?            timer.sw_pAIRSolve.Start();             AMG_solver.Mult(z_s, dpsi_dt);            timer.sw_pAIRSolve.Stop();              int Niter;            AMG_solver.GetNumIterations(Niter);            timer.pAIR_iter += Niter;            pAIR_it += Niter;         }         //dpsi_dt = dfMdv_gf;         dphi.Add(w[d] * dv, dpsi_dt);      }      // Update scalar flux phi.      phi = phi0;      phi += dphi;      // Norm of dphi.       loc_norm = dphi.Norml2();      MPI_Allreduce(&loc_norm, &glob_norm, 1, MPI_DOUBLE, MPI_SUM,                     fes.GetComm());      // Update residual.      res = abs(glob_norm - glob_norm0) / glob_norm;      // Update glob_norm0;      glob_norm0 = glob_norm;   }   if (myid == 0)    {       int precision = 4;      cout.precision(precision);      cout << scientific;      cout << "res(dphi) / scat_it / avg(pAIR_it) = " << res << " / "            << scat_it << " / "            << double(pAIR_it) / double(SN * scat_it) << endl;   }   // Contribution to the zero angular moment    // int_Omega int_v (phi+dphidt*dt) dOmega v^alpha dv.   // Assign grid function vector to phi after SN directions.   dphi_dt.MakeRef(&fes, du_dt, SN * Vsize);   dphi_dt = 0.0;   for (int d = 0; d < SN; d++)   {       // Assign grid function vectors for given direction d.      psi.MakeRef(&fes, *sptr, d * Vsize);      dpsi_dt.MakeRef(&fes, du_dt, d * Vsize);      // int_Omega (phi+dphidt*dt) dOmega.      dphi_dt.Add(w[d], psi);      //dphi_dt.Add(w[d] * dv, dpsi_dt);      dphi_dt.Add(w[d] * dt, dpsi_dt);   }   // Spherical coordinates velocity space metric.   // int_v int_Omega (phi+dphidt*dt) dOmega v^alpha dv.   // Number of particles moment => density.   //double Cunit = 1.0;   //double alpha = 2.0;      // Energy moment => temperature.   double Cunit = me / 3.0 / kB;   double alpha = 4.0;    dphi_dt *= Cunit * pow(velocity_glob, alpha);   // Destroy AMG_solver stuff, because T changes with direction d.   BlockInvScal(NULL, NULL, NULL, NULL, 0, -1);     for (int d = 0; d < Ts.Size(); d++)   {      if (T[d]) delete T[d];      if (Ts[d]) delete Ts[d];   }   /*   static int counter = 0;   counter ++;   T->Mult(-1.0, du_dt, 1.0, z);   printf("res %e\n", ParNormlp(z, 2.0, MPI_COMM_WORLD));   if (counter == 3) { exit(0); }   */}// Direction coefficientvoid direction_func(const Vector &x, Vector &v){   int dim = x.Size();   // Translations in 1D, 2D, and 3D   switch (dim)   {      case 1: v(0) = cos(ttheta); break;      //case 1: v(0) = cos(pphi); break;      case 2: v(0) = cos(ttheta); v(1) = sin(ttheta); break;      case 3: v(0) = cos(ttheta) * sin(pphi); v(1) = sin(ttheta) * sin(pphi);               v(2) = cos(pphi); break;   }}// Electron density spatial function.double ne_func(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   double X2 = 0.0;   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);      X2 += pow(X(i), 2);   }   //double ne_ref = 1.0;   return ne_ref;   //return ne_ref * (0.1 + 0.9 * (1.0 - exp(-10.0*X2)));}// Gradient of the electron density spatial function.void gradne_func(const Vector &x, Vector &gradne){   int dim = x.Size();   Vector x0(dim), x1(dim);   for (int i = 0; i < dim; i++)   {      // Central finite difference approximation.      double dx = 1e-6 * (bb_max[i] - bb_min[i]);       x0 = x; x1 = x;      x0[dim] -= dx;      x1[dim] += dx;      gradne[dim] = (ne_func(x1) - ne_func(x0)) / 2.0 / dx;   }}// Electron temperature spatial function.double Te_func(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   double X2 = 0.0;   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);      X2 += pow(X(i), 2);   }      //double Te0 = 1.0;   //return Te0;   return Te0 * (0.1 + 0.9 * exp(-10.*X2));}// Gradient of the electron temperature spatial function.void gradTe_func(const Vector &x, Vector &gradTe){   int dim = x.Size();   Vector x0(dim), x1(dim);   for (int i = 0; i < dim; i++)   {      // Central finite difference approximation.      double dx = 1e-6 * (bb_max[i] - bb_min[i]);       x0 = x; x1 = x;      x0[dim] -= dx;      x1[dim] += dx;      gradTe[dim] = (Te_func(x1) - Te_func(x0)) / 2.0 / dx;   }}// Thermal velocity spatial function.double vth_func(const Vector &x){   return pow(kB * Te_func(x) / me, 0.5);}// Thermal velocity spatial function.double coulLog_func(const Vector &x){   return 1.0;}// Ionization spatial function.double Zbar_func(const Vector &x){   //double Z0 = 1.0;   return Z0;}// Electric field function.void Efield_func(const Vector &x, Vector &E){   int dim = x.Size();   Vector ETe(dim), Ene(dim);   gradTe_func(x, ETe);   ETe *= 2.5 / Te_func(x);   gradne_func(x, Ene);   Ene *= 1.0 / ne_func(x);   E = 0.0;   E += ETe;   E += Ene;   // Local Lorentz E field scaling.   double E0 = 0.0;   E *= E0 * pow(vth_func(x), 2.0);}// E field projection to direction.double ndotE_func(const Vector &x){   int dim = x.Size();   // For simplicity we use a constant E field for now.   Vector Efield(dim), n(dim);   // Assign direction.   direction_func(x, n);   // Evaluate Efield.   Efield_func(x, Efield);   return Efield * n;}// BGK related collision cross section.double rB_func(const Vector &x){   double xi = (Zbar_func(x) + 0.24) / (Zbar_func(x) + 4.2);   return 1.0; //(zeta * Z) / xi / (Z + 2.0 * zeta);}double rBneGamma_therm_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return rB_func(x) * ne_func(x) * Gamma;}double rBneGamma_scat_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return rB_func(x) / zeta * ne_func(x) * Gamma * (Zbar_func(x) + zeta);}// AWBS related collision cross section.double neGammaHalf_therm_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return 0.5 * ne_func(x) * Gamma;}double neGammaHalf_scat_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return ne_func(x) * Gamma * (Zbar_func(x) + 0.5);   //return 0.0;}double fM_func(const Vector &x){   // fM = ne / 2pi^1.5 / vth^3 * exp(-v^2/2/vt^2).   double fM = ne_func(x) / pow(2.0 * pi, 1.5) / pow(vth_func(x), 3.0)               * exp(-pow(velocity_glob, 2.0) / 2.0 / pow(vth_func(x), 2.0));   return fM;}double dfMdv_func(const Vector &x){   // dfMdv = -v / vth^2 * fM   // where fM = ne / 2pi^1.5 / vth^3 * exp(-v^2/2/vt^2).   double dfMdv = - velocity_glob / pow(vth_func(x), 2.0) * fM_func(x);   return dfMdv;}// AWBS deceleration friction - E field projection to direction.double nue_ndotE_func(const Vector &x){   int dim = x.Size();   // For simplicity we use a constant E field for now.   Vector Efield(dim), n(dim);   // Assign direction.   direction_func(x, n);   // Evaluate Efield.   Efield_func(x, Efield);   // AWBS ee collision frequency.   double nue_AWBS = neGammaHalf_therm_func(x) / pow(velocity_glob, 3.0);   // Collective deceleration effect.   double deceler = nue_AWBS - Efield * n / velocity_glob;   // Limit the action to be a "slowing-down".   const double portion = 0.9;   if (deceler < portion * nue_AWBS) { deceler = portion * nue_AWBS; }   return deceler;}// Source of particlesdouble Q_BGK_func(const Vector &x){   // BGK source corresponds to    // fM = ne / 2pi^1.5 / vth^3 * exp(-v^2/2/vt^2).   return rBneGamma_therm_func(x) * fM_func(x);}// Source of particlesdouble Q_AWBS_func(const Vector &x){   // AWBS source corresponds to    // dfMdv = -v / vth^2 * fM   // where fM = ne / 2pi^1.5 / vth^3 * exp(-v^2/2/vt^2).   return neGammaHalf_therm_func(x) * dfMdv_func(x);}// Inflow boundary condition.double inflow_function(const Vector &x){   return init_value;}} // namespace TRguts// Do not use this main in some macro case.#ifndef ETR_NOMAINint main(int argc, char *argv[]){   // 1. Initialize MPI.   int num_procs, myid;   MPI_Init(&argc, &argv);   MPI_Comm_size(MPI_COMM_WORLD, &num_procs);   MPI_Comm_rank(MPI_COMM_WORLD, &myid);   // 1.5 Parse mesh command-line option and initialize mesh.   const char *mesh_file = "milan_data/ALE_quad.mesh"; //"./meshes/periodic-hexagon.mesh";    int ser_ref_levels = 0; //2;   int par_ref_levels = 0;   int ode_solver_type = 3;   int SN_azi = 8;   int Ngr = 100;   double ne_ref = 1e20;   double vini = 1.0;   double vfin = 0.1;   //int order = 3;   int scat_it_max = 20;   bool visualization = false;   //TRguts::AIR_parameters AIR = {1.5, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 6};   //TRguts::AIR_parameters AIR = {2, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 10};   const char* temp_prerelax = ""; //NULL;   const char* temp_postrelax = "FA"; //NULL;   TRguts::AIR_parameters AIR = {2, temp_prerelax, temp_postrelax,                                  0.1, 0.01, 0.0, 100, 10, 0.0001, 10};   OptionsParser args(argc, argv);   args.AddOption(&mesh_file, "-m", "--mesh",                       "Mesh file to use.");   args.AddOption(&ser_ref_levels, "-rs", "--refine-serial",                       "Number of times to refine the mesh uniformly in serial.");   args.AddOption(&par_ref_levels, "-rp", "--refine-parallel",                       "Number of times to refine the mesh uniformly in parallel.");   args.AddOption(&ode_solver_type, "-s", "--ode-solver",                  "ODE solver: 1 - Backward Euler, 2 - SDIRK2, 3 - SDIRK3,\n\t"                  "\t 11 - Forward Euler, 12 - RK2, 13 - RK3 SSP, 14 - RK4,\n\t"                  "\t 22 - Imp. midpoint, 23 - A-stable SDIRK3, 24 - A-stable SDIRK4.");   args.AddOption(&SN_azi, "-sna", "--SN_azimuthal",                  "Number of discrete ordinates in azimuthal angle.");   args.AddOption(&Ngr, "-Ngr", "--Num_groups",                  "Number of velocity groups.");   args.AddOption(&ne_ref, "-ne", "--ne-reference",                  "Reference density of plasma.");   args.AddOption(&vini, "-vini", "--v-initial",                  "Initial velocity of global vmax multiple.");   args.AddOption(&vfin, "-vfin", "--v-minimum",                  "Final velocity of global vmax multiple.");   args.AddOption(&scat_it_max, "-scit", "--scat_it_max",                  "Maximum number of scattering iterations.");   args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",                  "--no-visualization",                  "Enable or disable GLVis visualization.");     // AIR parser.   args.AddOption(&(AIR.distance), "-Ad", "--AIR-distance",                  "Distance restriction neighborhood for AIR.");   args.AddOption(&(AIR.interp_type), "-Ai", "--AIR-interpolation",                  "Index for hypre interpolation routine.");   args.AddOption(&(AIR.coarsening), "-Ac", "--AIR-coarsening",                  "Index for hypre coarsening routine.");   args.AddOption(&(AIR.strength_tolC), "-AsC", "--AIR-strengthC",                  "Theta value determining strong connections for AIR (coarsening).");   args.AddOption(&(AIR.strength_tolR), "-AsR", "--AIR-strengthR",                  "Theta value determining strong connections for AIR (restriction).");   args.AddOption(&(AIR.filter_tolR), "-AfR", "--AIR-filterR",                  "Theta value eliminating small entries in restriction (after building).");   args.AddOption(&(AIR.filterA_tol), "-Af", "--AIR-filter",                  "Theta value to eliminate small connections in AIR hierarchy. Use -1 to specify O(h).");   args.AddOption(&(AIR.relax_type), "-Ar", "--AIR-relaxation",                  "Index for hypre relaxation routine.");   args.AddOption(&temp_prerelax, "-Ar1", "--AIR-prerelax",                  "String denoting prerelaxation scheme; e.g., FCC.");   args.AddOption(&temp_postrelax, "-Ar2", "--AIR-postrelax",                  "String denoting postrelaxation scheme; e.g., FFC.");   args.Parse();     if (temp_prerelax != NULL) AIR.prerelax = std::string(temp_prerelax);   if (temp_postrelax != NULL) AIR.postrelax = std::string(temp_postrelax);   if (!args.Good())   {      if (myid == 0)      {         args.PrintUsage(cout);      }      MPI_Finalize();      return 1;   }   if (myid == 0)   {      args.PrintOptions(cout);   }   // 3. Read the serial mesh from the given mesh file on all processors. We can   //    handle geometrically periodic meshes in this code.   Mesh *mesh = new Mesh(mesh_file, 1, 1);   int dim = mesh->Dimension();   // 5. Refine the mesh in serial to increase the resolution. In this example   //    we do 'ser_ref_levels' of uniform refinement, where 'ser_ref_levels' is   //    a command-line parameter. If the mesh is of NURBS type, we convert it   //    to a (piecewise-polynomial) high-order mesh.   for (int lev = 0; lev < ser_ref_levels; lev++)   {      mesh->UniformRefinement();   }   if (mesh->NURBSext)   {      mesh->SetCurvature(1);      //mesh->SetCurvature(max(order, 1));   }   Vector bb_min, bb_max;    mesh->GetBoundingBox(bb_min, bb_max, 1);   //mesh->GetBoundingBox(bb_min, bb_max, max(order, 1));   // 6. Define the parallel mesh by a partitioning of the serial mesh. Refine   //    this mesh further in parallel to increase the resolution. Once the   //    parallel mesh is defined, the serial mesh can be deleted.   ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);   delete mesh;   for (int lev = 0; lev < par_ref_levels; lev++)   {      pmesh->UniformRefinement();   }   // Run TR example on the ParMesh pmesh.   TRguts::TRmain(pmesh, AIR, ne_ref,                   bb_min, bb_max,                   Ngr, ode_solver_type, SN_azi, vini, vfin, scat_it_max,                  visualization);   delete pmesh;    MPI_Finalize();   return 0;}#endif