//                       MFEM Example 9 - Parallel Version//// Compile with: make ex9p//// Sample runs://    mpirun -np 4 ex9p -m ../data/periodic-segment.mesh -p 0 -dt 0.005//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/amr-quad.mesh -p 1 -rp 1 -dt 0.002 -tf 9//    mpirun -np 4 ex9p -m ../data/star-q3.mesh -p 1 -rp 1 -dt 0.004 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 1 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 2 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 3 -rp 2 -dt 0.0025 -tf 9 -vs 20//    mpirun -np 4 ex9p -m ../data/periodic-cube.mesh -p 0 -o 2 -rp 1 -dt 0.01 -tf 8////    MFEM_adv steady-state test runs//    1D currently not implemented.//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 5 -s 1 -col 1//    2D//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 5 -s 1 -col 1//    2D AMR//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 5 -s 1 -col 1//    High azimuthal resolution test.//    mpirun -np 4 ex23TRp -m ../data/inline-segment.mesh -p 0 -rp 0 -tf 2000000 -dt 1000 -s 1 -col 5 -sna 12//    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 0 -tf 2000000 -dt 100000 -s 1 -col 5 -sna 12//    mpirun -np 4 ex23TRp -m ../data/amr-quad.mesh -p 0 -rp 0 -tf 2000000 -dt 2000000 -s 1 -col 5 -sna 12 //    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 0 -tf 0.3 -dt 0.01 -s 1 -col 5 -sna 5//    mpirun -np 4 ex23TRp -m ../data/inline-quad.mesh -p 0 -rp 1 -tf 0.23 -dt 0.01 -s 1 -col 5 -sna 5     //// Description:  This example code solves the time-dependent advection equation//               du/dt + v.grad(u) = 0, where v is a given fluid velocity, and//               u0(x)=u(0,x) is a given initial condition.////               The example demonstrates the use of Discontinuous Galerkin (DG)//               bilinear forms in MFEM (face integrators), the use of explicit//               ODE time integrators, the definition of periodic boundary//               conditions through periodic meshes, as well as the use of GLVis//               for persistent visualization of a time-evolving solution. The//               saving of time-dependent data files for external visualization//               with VisIt (visit.llnl.gov) is also illustrated.// This problem seems to like an FFC rekaxation...#include "mfem.hpp"#include <fstream>#include <iostream>using namespace std;using namespace mfem;// Include explicit TR code (within TRguts namespace).#include "TRgutsp.cpp"// Choice for the problem setup. The fluid velocity, initial condition and// inflow boundary condition are chosen based on this parameter.int problem;// Boltzmann constant.const double kB = 1.0; // 1.6022e-12; // [cgs, eV]// Electron mass.const double me = 1.0; // 9.1094e-28; // [cgs]// Pi.const double pi = atan(1.0)*4.0;// Collision frequency cross section.double sigma = 1.0; // 8.1027575e17 // Matching the SH diffusive flux.// TMP values.double ne0 = 1.0;double Z0 = 1.0;double zeta = 2.0;// Angles for discretization of velocity space.double ttheta = 0.0;double pphi = 0.0;// Tolerance to solve linear system todouble solve_tol;int use_gmres;int myid;// Direction coefficientvoid direction_func(const Vector &x, Vector &v);// E field projection to direction coefficient.double ndotE_func(const Vector &x);// Inflow boundary condition//double inflow_function(const Vector &x);// Global value of current velocity to be used for source evaluation.double velocity = 1.0;// BGK related collision cross section.double rBneGamma_therm_func(const Vector &x);double rBneGamma_scat_func(const Vector &x);// AWBS related collision cross section.double neGammaHalf_therm_func(const Vector &x);double neGammaHalf_scat_func(const Vector &x);// Source of particlesdouble Q_BGK_func(const Vector &x);double Q_AWBS_func(const Vector &x);// Mesh bounding boxVector bb_min, bb_max;struct AIR_parameters {   // Options: LAIR: {1, 1.5, 2}, NAIR: {3, 4, 5} - default 1.5   //    LAIR is more robust on non-triangular matrices, NAIR should be   //    faster to setup at the cost of slightly degraded convergence.    //    E.g., NAIR 4 corresponds to distance 4-2=2 restriction.   double distance;   // Options string consisting of F, C, or A; e.g., "FFC" or "FA"   //    Default: prerelax = "", postrelax = "FA" (FA specifically   //    for type 10 relax)   std::string prerelax;   std::string postrelax;   // Strength tolerance for coarsening. Default 0.1, can be problem   // dependent. Try between 0.01 and 0.5, typically in the middle.   double strength_tolC;   // Tolerance for building restriction. Smaller is better, typically    // 0.01 (default) or so.    double strength_tolR;   // Remove small entries from R. Default 0, strategy we are testing to   // reduce complexity.    double filter_tolR;   // Default 100 (simple interpolation). Can also use 6 (classical interp).   int interp_type;   // Default 10 (processor block Jacobi, i.e., ordered on processor Gauss-   // Seidel). Can also use 0 (Jacobi) or 3 (on processor, unordered Gauss-   // Seidel)   int relax_type;   // Eliminate small entries from the matrix to reduce memory/complexity.   // Default 1e-4. Can degrade convergence, if so make smaller.   double filterA_tol;   // Default 6, coarsens not aggressively. Can also use 3 (slower in    // parallel, also not aggressive coarsening) or 10 (more aggressive   // coarsening).   int coarsening;};void print_AIR(AIR_parameters AIR) {   std::cout << "Distance R:   " << AIR.distance << "\n" \             << "Prerelax:     " << AIR.prerelax << "\n" \             << "Postrelax:    " << AIR.postrelax << "\n" \             << "Strength C:   " << AIR.strength_tolC << "\n" \             << "Strength R:   " << AIR.strength_tolR << "\n" \             << "Interp type:  " << AIR.interp_type << "\n" \             << "Relax type:   " << AIR.relax_type << "\n" \             << "Coarsen type: " << AIR.coarsening << "\n" \             << "Filter tol:   " << AIR.filterA_tol << ".\n";}/** A time-dependent operator for the right-hand side of the ODE. The DG weak    form of du/dt = -v.grad(u) + sigma (q - u) is M du/dt = K u + b, where M     and K are the mass and the advection minus the absorption matrices, and b     describes the volumetric source and the flow on the boundary. This can be     written as a general ODE, du/dt = M^{-1} (K u + b), and this class     is used to evaluate the right-hand side. */class FE_Evolution : public TimeDependentOperator{private:    HypreParMatrix &Maux;   const Array<HypreParMatrix*> &Ms, &MEs, &Ks;   HypreParMatrix *T;   // For each SN direction d we solve T_d = M - dt (K_d - Ma);   const Vector &b;   HypreSmoother M_prec;   CGSolver M_solver;   /* Precond/Solver for T */   HypreBoomerAMG *AMG_solver;   //HypreGMRES     *GMRES_solver;   /* scaled version of T and z */   HypreParMatrix T_s;   ParFiniteElementSpace &fes;   mutable Vector z;   double current_dt;   int SN;   const Array<double> w;   int blocksize;   AIR_parameters AIR;   //Coefficient *source_cf;public:   FE_Evolution(ParFiniteElementSpace &_fes,                HypreParMatrix &_Maux,                const Array<HypreParMatrix*> &_Ms,                const Array<double> &_w,                const Array<HypreParMatrix*> &_MEs,                 const Array<HypreParMatrix*> &_Ks,                  const Vector &_b, const int order,                 const AIR_parameters *AIR_init=NULL);   virtual void Mult(const Vector &x, Vector &y) const;   /** Solve the Backward-Euler equation: d = f(x + dt*d, t+dt), where u_t = f(x,t).       This is the only requirement for high-order SDIRK implicit integration.*/   virtual void ImplicitSolve(const double dt, const Vector &u, Vector &k);   void Destroy()   {      BlockInvScal(NULL, NULL, NULL, NULL, 0, -1);      if (T) delete T;      if (AMG_solver) delete AMG_solver;      //if (GMRES_solver) delete GMRES_solver;   }   //virtual ~FE_Evolution() { }};int main(int argc, char *argv[]){   // 1. Initialize MPI.   int num_procs;   MPI_Init(&argc, &argv);   MPI_Comm_size(MPI_COMM_WORLD, &num_procs);   MPI_Comm_rank(MPI_COMM_WORLD, &myid);   // 1.5 Parse mesh command-line option and initialize mesh.   const char *mesh_file = "./meshes/periodic-hexagon.mesh";   int ser_ref_levels = 2;   int par_ref_levels = 0;   //int order = 3;   OptionsParser args_mesh(argc, argv);   args_mesh.AddOption(&mesh_file, "-m", "--mesh",                       "Mesh file to use.");   args_mesh.AddOption(&ser_ref_levels, "-rs", "--refine-serial",                       "Number of times to refine the mesh uniformly in serial.");   args_mesh.AddOption(&par_ref_levels, "-rp", "--refine-parallel",                       "Number of times to refine the mesh uniformly in parallel.");   //args_mesh.AddOption(&order, "-o", "--order",   //                    "Order (degree) of the finite elements.");   args_mesh.Parse();   // 3. Read the serial mesh from the given mesh file on all processors. We can   //    handle geometrically periodic meshes in this code.   Mesh *mesh = new Mesh(mesh_file, 1, 1);   int dim = mesh->Dimension();   // 5. Refine the mesh in serial to increase the resolution. In this example   //    we do 'ser_ref_levels' of uniform refinement, where 'ser_ref_levels' is   //    a command-line parameter. If the mesh is of NURBS type, we convert it   //    to a (piecewise-polynomial) high-order mesh.   for (int lev = 0; lev < ser_ref_levels; lev++)   {      mesh->UniformRefinement();   }   if (mesh->NURBSext)   {      mesh->SetCurvature(1);      //mesh->SetCurvature(max(order, 1));   }   mesh->GetBoundingBox(bb_min, bb_max, 1);   //mesh->GetBoundingBox(bb_min, bb_max, max(order, 1));   // 6. Define the parallel mesh by a partitioning of the serial mesh. Refine   //    this mesh further in parallel to increase the resolution. Once the   //    parallel mesh is defined, the serial mesh can be deleted.   ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);   delete mesh;   for (int lev = 0; lev < par_ref_levels; lev++)   {      pmesh->UniformRefinement();   }   // 2. Parse command-line options.   problem = 0;   solve_tol = 1e-8;   use_gmres = 0;   //const char *mesh_file = "./meshes/periodic-hexagon.mesh";   //int ser_ref_levels = 2;   //int par_ref_levels = 0;   int order = 3;   int SN_pol = 1.0;   int SN_azi = 4.0;   int ode_solver_type = 14;   double t_final = 10.0;   double dt = 0.1;   int num_time_steps = -1;   bool visualization = true;   bool visit = false;   bool binary = false;   int vis_steps = 5;   int precision = 8;   cout.precision(precision);   //AIR_parameters AIR = {1.5, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 6};   AIR_parameters AIR = {2, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 10};   const char* temp_prerelax = NULL;   const char* temp_postrelax = NULL;   double h_min, h_max, k_min, k_max;   cout << "DBG main before argsparsing." << endl << flush;   OptionsParser args(argc, argv);   args.AddOption(&mesh_file, "-m", "--mesh",                  "Mesh file to use.");   args.AddOption(&problem, "-p", "--problem",                  "Problem setup to use. See options in velocity_function().");   args.AddOption(&ser_ref_levels, "-rs", "--refine-serial",                  "Number of times to refine the mesh uniformly in serial.");   args.AddOption(&par_ref_levels, "-rp", "--refine-parallel",                  "Number of times to refine the mesh uniformly in parallel.");   args.AddOption(&order, "-o", "--order",                  "Order (degree) of the finite elements.");   args.AddOption(&SN_azi, "-sna", "--SN_azimuthal",                  "Number of discrete ordinates in azimuthal angle.");   args.AddOption(&use_gmres, "-gmres", "--use-gmres",                  "Boolean to use GMRES acceleration with AIR.");   args.AddOption(&ode_solver_type, "-s", "--ode-solver",                  "ODE solver: 1 - Backward Euler, 2 - SDIRK2, 3 - SDIRK3,\n\t"                  "\t   11 - Forward Euler, 12 - RK2, 13 - RK3 SSP, 14 - RK4,\n\t"                  "\t   22 - Imp. midpoint, 23 - A-stable SDIRK3, 34 - A-stable SDIRK4.");   args.AddOption(&t_final, "-tf", "--t-final",                  "Final time; start time is 0.");   args.AddOption(&num_time_steps, "-nt", "--num-time-steps",                  "Number of time steps to take. Uses dt and overrides final time.");   args.AddOption(&solve_tol, "-tol", "--tolerance",                  "Tolerance to solve linear system to. Use -1 for tol=dt.");   args.AddOption(&dt, "-dt", "--time-step",                  "Time step. If dt = z < 0, dt := h^z, for mesh size h.");   args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",                  "--no-visualization",                  "Enable or disable GLVis visualization.");   args.AddOption(&visit, "-visit", "--visit-datafiles", "-no-visit",                  "--no-visit-datafiles",                  "Save data files for VisIt (visit.llnl.gov) visualization.");   args.AddOption(&binary, "-binary", "--binary-datafiles", "-ascii",                  "--ascii-datafiles",                  "Use binary (Sidre) or ascii format for VisIt data files.");   args.AddOption(&vis_steps, "-vs", "--visualization-steps",                  "Visualize every n-th timestep.");   args.AddOption(&sigma, "-col", "--sigma-collisions",                  "Collision frequency cross section.");    args.AddOption(&(AIR.distance), "-Ad", "--AIR-distance",                  "Distance restriction neighborhood for AIR.");    args.AddOption(&(AIR.interp_type), "-Ai", "--AIR-interpolation",                  "Index for hypre interpolation routine.");    args.AddOption(&(AIR.coarsening), "-Ac", "--AIR-coarsening",                  "Index for hypre coarsening routine.");    args.AddOption(&(AIR.strength_tolC), "-AsC", "--AIR-strengthC",                   "Theta value determining strong connections for AIR (coarsening).");    args.AddOption(&(AIR.strength_tolR), "-AsR", "--AIR-strengthR",                   "Theta value determining strong connections for AIR (restriction).");    args.AddOption(&(AIR.filter_tolR), "-AfR", "--AIR-filterR",                   "Theta value eliminating small entries in restriction (after building).");    args.AddOption(&(AIR.filterA_tol), "-Af", "--AIR-filter",                  "Theta value to eliminate small connections in AIR hierarchy. Use -1 to specify O(h).");    args.AddOption(&(AIR.relax_type), "-Ar", "--AIR-relaxation",                  "Index for hypre relaxation routine.");    args.AddOption(&temp_prerelax, "-Ar1", "--AIR-prerelax",                  "String denoting prerelaxation scheme; e.g., FCC.");    args.AddOption(&temp_postrelax, "-Ar2", "--AIR-postrelax",                  "String denoting postrelaxation scheme; e.g., FFC.");   args.Parse();     if (temp_prerelax != NULL) AIR.prerelax = std::string(temp_prerelax);   if (temp_postrelax != NULL) AIR.postrelax = std::string(temp_postrelax);   if (!args.Good())   {      if (myid == 0)      {         args.PrintUsage(cout);      }      MPI_Finalize();      return 1;   }   if (myid == 0)   {      // args.PrintOptions(cout);   }   cout << "DBG main after argsparsing." << endl << flush;   // Get mesh size, set time step and solve tol accordingly, if specified   pmesh->GetCharacteristics(h_min, h_max, k_min, k_max);   if (dt < 0) dt = pow(h_max,- velocity * dt);   if (solve_tol < 0) {      solve_tol = dt;      if (myid == 0) std::cout << "Solve tolerance = dt = " << dt << "\n";   }     // 4. Define the ODE solver used for time integration. Several explicit   //    Runge-Kutta methods are available.   ODESolver *ode_solver = NULL;   switch (ode_solver_type)   {      // Implicit L-stable methods      case 1:  ode_solver = new BackwardEulerSolver; break;      case 2:  ode_solver = new SDIRK23Solver(2); break;      case 3:  ode_solver = new SDIRK33Solver; break;      // Explicit methods      case 11: ode_solver = new ForwardEulerSolver; break;      case 12: ode_solver = new RK2Solver(0.5); break; // midpoint method      case 13: ode_solver = new RK3SSPSolver; break;      case 14: ode_solver = new RK4Solver; break;      // Implicit A-stable methods (not L-stable)      case 22: ode_solver = new ImplicitMidpointSolver; break;      case 23: ode_solver = new SDIRK23Solver; break;      case 24: ode_solver = new SDIRK34Solver; break;      default:         cout << "Unknown ODE solver type: " << ode_solver_type << '\n';         return 3;   }   cout << "DBG main before fes." << endl << flush;   // 7. Define the parallel discontinuous DG finite element space on the   //    parallel refined mesh of the given polynomial order.   DG_FECollection fec(order, dim);   ParFiniteElementSpace *fes = new ParFiniteElementSpace(pmesh, &fec);   cout << "DBG main after fes." << endl << flush;   HYPRE_Int global_vSize = fes->GlobalTrueVSize();   if (myid == 0) {      cout << "Number of unknowns: " << global_vSize << endl;      cout << "Block size: " << (order+1)*(order+1) << endl;   }   // 8. Set up and assemble the parallel bilinear and linear forms (and the   //    parallel hypre matrices) corresponding to the DG discretization. The   //    DGTraceIntegrator involves integrals over mesh interior faces.    ParLinearForm *b = new ParLinearForm(fes);   //b->AddBdrFaceIntegrator(new BoundaryFlowIntegrator(inflow, velocity, -1.0, -0.5));   // Add source of particles.      FunctionCoefficient Q_BGK_cf(Q_BGK_func);   b->AddDomainIntegrator(new DomainLFIntegrator(Q_BGK_cf));   b->Assemble();   HypreParVector *B = b->ParallelAssemble();   // Coefficients to be used.   ConstantCoefficient zero_cf(0.0);   ConstantCoefficient one_cf(1.0);   FunctionCoefficient neGammaHalf_therm_cf(neGammaHalf_therm_func);   FunctionCoefficient neGammaHalf_scat_cf(neGammaHalf_scat_func);   FunctionCoefficient rBneGamma_therm_cf(rBneGamma_therm_func);   FunctionCoefficient rBneGamma_scat_cf(rBneGamma_scat_func);   VectorFunctionCoefficient direction(dim, direction_func);   FunctionCoefficient ndotE_cf(ndotE_func);   int skip_zeros = 0;   // Prepare an auxiliary zero mass matrix to be used to do "sum"   // of mass-block-diagonal Hypre matrices instead of expensive "add".   ParBilinearForm *maux = new ParBilinearForm(fes);   maux->AddDomainIntegrator(new MassIntegrator(zero_cf));   maux->Assemble(skip_zeros);   maux->Finalize(skip_zeros);   HypreParMatrix *Maux = maux->ParallelAssemble();   // Gather mass based bilinear forms (block-diagonal).   Array<ParBilinearForm*> ms;   // Add standart one mass matrix for time evolution.   ParBilinearForm *mone = new ParBilinearForm(fes);   mone->AddDomainIntegrator(new MassIntegrator(one_cf));   mone->Assemble(skip_zeros);   mone->Finalize(skip_zeros);   ms.Append(mone);   // Add BGK thermalization mass matrix.   ParBilinearForm *mth_BGK = new ParBilinearForm(fes);   mth_BGK->AddDomainIntegrator(new MassIntegrator(rBneGamma_therm_cf));   mth_BGK->Assemble(skip_zeros);   mth_BGK->Finalize(skip_zeros);   ms.Append(mth_BGK);   // Add BGK scattering mass matrix.   ParBilinearForm *mscat_BGK = new ParBilinearForm(fes);   mscat_BGK->AddDomainIntegrator(new MassIntegrator(rBneGamma_scat_cf));   mscat_BGK->Assemble(skip_zeros);   mscat_BGK->Finalize(skip_zeros);   ms.Append(mscat_BGK);   // Add AWBS thermalization mass matrix.   ParBilinearForm *mth_AWBS = new ParBilinearForm(fes);   mth_AWBS->AddDomainIntegrator(new MassIntegrator(neGammaHalf_therm_cf));   mth_AWBS->Assemble(skip_zeros);   mth_AWBS->Finalize(skip_zeros);   ms.Append(mth_AWBS);   // Add AWBS scattering mass matrix.   ParBilinearForm *mscat_AWBS = new ParBilinearForm(fes);   mscat_AWBS->AddDomainIntegrator(new MassIntegrator(neGammaHalf_scat_cf));   mscat_AWBS->Assemble(skip_zeros);   mscat_AWBS->Finalize(skip_zeros);   ms.Append(mscat_AWBS);   // Special treatment of the angular dependent components.   // Advection matrix for each SN direction.    double dtheta = 2.0 * pi / double(SN_azi);   Array<ParBilinearForm*> ks;   Array<ParBilinearForm*> mEs;    Array<double> w;    for (int dp = 0; dp < SN_pol; dp++)   {      double wp = 2.0;      for (int da = 0; da < SN_azi; da++)      {         // Set azimuthal angle theta to define direction.          ttheta = da * dtheta;         //cout << "ttheta: " << ttheta << endl;         // Add advection matrix for given direction.         ParBilinearForm *k = new ParBilinearForm(fes);           k->AddDomainIntegrator(new ConvectionIntegrator(direction, -1.0));         k->AddInteriorFaceIntegrator(            new TransposeIntegrator(new DGTraceIntegrator(direction, 1.0, -0.5)));         k->AddBdrFaceIntegrator(            new TransposeIntegrator(new DGTraceIntegrator(direction, 1.0, -0.5)));         k->Assemble(skip_zeros);         k->Finalize(skip_zeros);         ks.Append(k);         // Add ndotE mass matrix for given direction.         ParBilinearForm *mE = new ParBilinearForm(fes);         mE->AddDomainIntegrator(new MassIntegrator(ndotE_cf));         mE->Assemble(skip_zeros);         mE->Finalize(skip_zeros);         mEs.Append(mE);         // Add appropriate weight related to direction d.         double wa = dtheta;         w.Append(wp * wa);      }   }   // Total number of SN directions.   int SN = ks.Size();   cout << "DBG SN: " << SN << endl << flush;   // Transalte bilinear forms to Hypre matrices.   // Particular mass matrices.   Array<HypreParMatrix*> Ms;   for (int i = 0; i < ms.Size(); i++)   {      Ms.Append(ms[i]->ParallelAssemble());   }   // Direction dependent matrices.   Array<HypreParMatrix*> Ks;   Array<HypreParMatrix*> MEs;   for (int d = 0; d < SN; d++)   {      Ks.Append(ks[d]->ParallelAssemble());      MEs.Append(mEs[d]->ParallelAssemble());   }   // 9. Define the initial conditions, save the corresponding grid function to   //    a file and (optionally) save data in the VisIt format and initialize   //    GLVis visualization.      // All directions psi are integrated in time as a system, we group them    // together in block vector Psi, on the unique parallel degrees of freedom,    // with offsets given by array true_offset.   int true_size = fes->TrueVSize();   Array<int> true_offset(SN+1);   for (int o = 0; o < SN + 1; o++) { true_offset[o] = o * true_size; }   BlockVector Psi(true_offset);   Array<ParGridFunction *> psi_Agf;   for (int o = 0; o < SN; o++)    {       ParGridFunction *psi_pgf = new ParGridFunction(fes);       psi_pgf->MakeTRef(fes, Psi, true_offset[o]);      psi_pgf->ProjectCoefficient(zero_cf);      psi_pgf->SetTrueVector();      psi_pgf->SetFromTrueVector();      psi_Agf.Append(psi_pgf);   }   // Scalar flux.   ParGridFunction phi_gf(fes);   {      ostringstream mesh_name, sol_name;      mesh_name << "ex23TR-mesh." << setfill('0') << setw(6) << myid;      sol_name << "ex23TR-init." << setfill('0') << setw(6) << myid;      ofstream omesh(mesh_name.str().c_str());      omesh.precision(precision);      pmesh->Print(omesh);      ofstream osol(sol_name.str().c_str());      osol.precision(precision);      phi_gf.Save(osol);   }   // Create data collection for solution output: either VisItDataCollection for   // ascii data files, or SidreDataCollection for binary data files.   DataCollection *dc = NULL;   if (visit)   {      if (binary)      {#ifdef MFEM_USE_SIDRE         dc = new SidreDataCollection("Example9-Parallel", pmesh);#else         MFEM_ABORT("Must build with MFEM_USE_SIDRE=YES for binary output.");#endif      }      else      {         dc = new VisItDataCollection("Example9-Parallel", pmesh);         dc->SetPrecision(precision);         // To save the mesh using MFEM's parallel mesh format:         // dc->SetFormat(DataCollection::PARALLEL_FORMAT);      }      dc->RegisterField("solution", &phi_gf);      dc->SetCycle(0);      dc->SetTime(0.0);      dc->Save();   }   socketstream sout;   if (visualization)   {      char vishost[] = "localhost";      int  visport   = 19916;      sout.open(vishost, visport);      if (!sout)      {         if (myid == 0)            cout << "Unable to connect to GLVis server at "                 << vishost << ':' << visport << endl;         visualization = false;         if (myid == 0)         {            cout << "GLVis visualization disabled.\n";         }      }      else      {         sout << "parallel " << num_procs << " " << myid << "\n";         sout.precision(precision);         sout << "solution\n" << *pmesh << *(psi_Agf[SN-1]);         sout << "pause\n";         sout << flush;         if (myid == 0)            cout << "GLVis visualization paused."                 << " Press space (in the GLVis window) to resume it.\n";      }   }   // 10. Define the time-dependent evolution operator describing the ODE   //     right-hand side, and perform time-integration (looping over the time   //     iterations, ti, with a time-step dt).   FE_Evolution adv(*fes, *Maux, Ms, w, MEs, Ks, *B, order, &AIR);   double t = 0.0;   if (num_time_steps > 0) t_final = num_time_steps * dt;   adv.SetTime(t);   ode_solver->Init(adv);   bool done = false;   for (int ti = 0; !done; )   {      double dt_real = min(dt, t_final - t);      ode_solver->Step(Psi, t, dt_real);      ti++;      done = (t >= t_final - 1e-8*dt);      if (done || ti % vis_steps == 0)      {         if (myid == 0)         {            cout << "time step: " << ti << ", time: " << t << endl;         }         // 11. Extract the parallel grid function corresponding to the finite         //     element approximation Psi (the local solution on each processor).         phi_gf = 0.0;         for (int d = 0; d < SN; d++)         {            psi_Agf[d]->SetFromTrueVector();            phi_gf.Add(w[d], *(psi_Agf[d]));         }         if (visualization)         {            sout << "parallel " << num_procs << " " << myid << "\n";            //sout << "solution\n" << *pmesh << *(psi_Agf[SN-1]) << flush;            sout << "solution\n" << *pmesh << phi_gf << flush;         }         if (visit)         {            dc->SetCycle(ti);            dc->SetTime(t);            dc->Save();         }      }   }   // Run TR example on the ParMesh pmesh.   TRguts::TRmain(pmesh, bb_min, bb_max);   //TRguts::TRmain(argc, argv, pmesh);   cout << "DBG TRmain finished!" << endl << flush;   //MPI_Comm_size(MPI_COMM_WORLD, &num_procs);   //MPI_Comm_rank(MPI_COMM_WORLD, &myid);   // 13. Free the used memory.   delete B;   delete b;   delete Maux;   delete maux;   for (int i = 0; i < ms.Size(); i++)    {       delete ms[i];      delete Ms[i];    }   for (int d = 0; d < SN; d++)   {      delete ks[d];      delete Ks[d];      delete mEs[d];      delete MEs[d];      delete psi_Agf[d];   }   delete fes;   delete pmesh;   delete ode_solver;   adv.Destroy();    MPI_Finalize();   return 0;}// Implementation of class FE_EvolutionFE_Evolution::FE_Evolution(ParFiniteElementSpace &_fes,                            HypreParMatrix &_Maux,                           const Array<HypreParMatrix*> &_Ms,                           const Array<double> &_w,                           const Array<HypreParMatrix*> &_MEs,                           const Array<HypreParMatrix*> &_Ks,                            const Vector &_b, const int order,                           const AIR_parameters *AIR_init)   : TimeDependentOperator(_fes.GetVSize() * _Ks.Size()), fes(_fes),                           Maux(_Maux), Ms(_Ms), MEs(_MEs), Ks(_Ks),                            w(_w), b(_b), M_solver(_fes.GetComm()),                            z(_fes.GetVSize()){   Maux = 0.0;   Maux.Add(1.0 / velocity, *(Ms[0]));   M_prec.SetType(HypreSmoother::Jacobi);   M_solver.SetPreconditioner(M_prec);   M_solver.SetOperator(Maux);   M_solver.iterative_mode = false;   M_solver.SetRelTol(1e-9);   M_solver.SetAbsTol(0.0);   M_solver.SetMaxIter(100);   M_solver.SetPrintLevel(0);   // Number of SN directions.   SN = Ks.Size();   T = NULL;   AMG_solver = NULL;   //GMRES_solver = NULL;   if (AIR_init) AIR = *AIR_init;   // DG block size given by (FEorder+1)^2 on square meshes.   blocksize = (order+1)*(order+1);   // TEST @MH Check the mass matrices sparsity for Hypre.   Maux = 0.0;   Maux.Add(1.0, *(Ms[0])); // Same sparsity -> works!   //Maux.Add(1.0, *(Ks[1])); // Different sparcity -> does not work!}void FE_Evolution::Mult(const Vector &x, Vector &y) const{   // The monolithic BlockVector stores the unknown fields as follows:   // (psi_1, .., psi_SN).   Vector* sptr = (Vector*) &x;   const int Vsize = fes.GetVSize();   Vector z_aux(Vsize);   ParGridFunction psix, psiy;    // Assign BGK collision mass matrix.   HypreParMatrix &MaBGK = *(Ms[1]);      // y = M^{-1} (K x + b)   for (int d = 0; d < SN; d++)   {      // Assign grid function vectors for given direction d.      psix.MakeRef(&fes, *sptr, d * Vsize);      psiy.MakeRef(&fes, y, d * Vsize);      // Assign advection matrix for given direction d.      HypreParMatrix &nGrad = *(Ks[d]);            nGrad.Mult(psix, z);      MaBGK.Mult(psix, z_aux);      z -= z_aux;      z += b;      M_solver.Mult(z, psiy);   }}void FE_Evolution::ImplicitSolve(const double dt, const Vector &u, Vector &du_dt){   // The monolithic BlockVector stores the unknown fields as follows:   // (psi_1, .., psi_SN).   Vector* sptr = (Vector*) &u;   const int Vsize = fes.GetVSize();   Vector z_aux(Vsize);   ParGridFunction psi, dpsi_dt;   ParGridFunction phi0(&fes), phi(&fes), dphi0(&fes), dphi(&fes);   // Angular integration of previous time step scalar flux phi0.   phi0 = 0.0;   double fourpi = 0.0;   for (int d = 0; d < SN; d++)   {      // Assign grid function vectors for given direction d.      psi.MakeRef(&fes, *sptr, d * Vsize);      phi0.Add(w[d], psi);      fourpi += w[d];   }   // Initial guess for scalar flux is the old value.   phi = phi0;    // Assign standard one-mass matrix and BGK collision mass matrix.   HypreParMatrix &Mone = *(Ms[0]);   HypreParMatrix &MaBGK = *(Ms[1]);    // Sum corresponding mass matrices.   Maux = 0.0;   Maux.Add(1.0, Mone);   Maux.Add(dt, MaBGK);   int Nit_scat = 1;   for (int it_scat = 0; it_scat < Nit_scat; it_scat++)   {   // Solve the equation:   //    u_t = M^{-1}((K - Ma) u + b),    // by solving associated linear system   //    (M - dt*(K - Ma)) du_dt = (K - Ma) u + b   //    TODO: Is mass matrix lower triangular??   for (int d = 0; d < SN; d++)   {      // Assign grid function vectors for given direction d.      psi.MakeRef(&fes, *sptr, d * Vsize);      dpsi_dt.MakeRef(&fes, du_dt, d * Vsize);      // Assign advection matrix for given direction d.      HypreParMatrix &nGrad = *(Ks[d]);      if (!T) {         /* T is NULL, this should be the first solve with T,          * scale T, setup AMG and GMRES */         T = HypreParMatrixAdd(1.0 / velocity, Maux, -1.0*dt, nGrad);         current_dt = dt;         /* scale T by block-diagonal inverse */         BlockInvScal(T, &T_s, NULL, NULL, blocksize, 0);         if (myid == 0) std::cout << "direction: " << d                                  << " , assembled matrices: "                                   << T->GetNumRows() << ", " \                                  << T->GetNumCols() << ", "                                   << T->NNZ() << "\n";          AMG_solver = new HypreBoomerAMG(T_s);         AMG_solver->SetLAIROptions(AIR.distance, AIR.prerelax,                                     AIR.postrelax, AIR.strength_tolC,                                     AIR.strength_tolR, AIR.filter_tolR,                                    AIR.interp_type, AIR.relax_type,                                     AIR.filterA_tol, AIR.coarsening);         //AMG_solver->SetNAIROptions(5, AIR.prerelax,          //                           AIR.postrelax, AIR.strength_tolC,          //                           AIR.strength_tolR, AIR.filter_tolR,         //                           AIR.interp_type, AIR.relax_type,          //                           AIR.filterA_tol, AIR.coarsening);         if (!use_gmres) {            AMG_solver->SetPrintLevel(0);            AMG_solver->SetTol(solve_tol);            AMG_solver->SetMaxIter(500);         }         else {            /*            HypreGMRES *GMRES_solver = new HypreGMRES(T_s);            GMRES_solver->SetAbsTol(solve_tol);            GMRES_solver->SetMaxIter(500);            GMRES_solver->SetPrintLevel(1);            GMRES_solver->SetPreconditioner(*AMG_solver_loc);            */            /* TODO zero init guess ? */            //GMRES_solver->SetZeroInintialIterate();            //GMRES_solver->iterative_mode = false;         }      }      MFEM_VERIFY(dt == current_dt, ""); // SDIRK methods use the same dt      nGrad.Mult(psi, z);      MaBGK.Mult(psi, z_aux);      z -= z_aux;      z += b;      /* scale the rhs and solve system */      HypreParVector z_s;      BlockInvScal(T, NULL, &z, &z_s, blocksize, 2);      if (use_gmres){         //GMRES_solver->Mult(z_s, dpsi_dt);      }      else {         AMG_solver->Mult(z_s, dpsi_dt);      }      // Contribution to scalar flux.      dphi.Add(w[d] * dt, dpsi_dt);            // Destroy AMG_solver stuff, because T changes with direction d.      //BlockInvScal(NULL, NULL, NULL, NULL, 0, -1);            delete T;      delete AMG_solver;      T = NULL;      AMG_solver = NULL;      //delete GMRES_solver;   }   // Update scalar flux phi.   phi = phi0;   phi += dphi;   }   /*   static int counter = 0;   counter ++;   T->Mult(-1.0, du_dt, 1.0, z);   printf("res %e\n", ParNormlp(z, 2.0, MPI_COMM_WORLD));   if (counter == 3) { exit(0); }   */}// Direction coefficientvoid direction_func(const Vector &x, Vector &v){   int dim = x.Size();   // Translations in 1D, 2D, and 3D   switch (dim)   {      case 1: v(0) = cos(ttheta); break;      //case 1: v(0) = cos(pphi); break;      case 2: v(0) = cos(ttheta); v(1) = sin(ttheta); break;      case 3: v(0) = cos(ttheta) * sin(pphi); v(1) = sin(ttheta) * sin(pphi);               v(2) = cos(pphi); break;   }}// Direction coefficientvoid Efield_func(const Vector &x, Vector &v){   // Constant field for testing.   v = 1.0;}// E field projection to direction.double ndotE_func(const Vector &x){   int dim = x.Size();   // For simplicity we use a constant E field for now.   Vector Efield(dim), n(dim);   // Assign direction.   direction_func(x, n);   // Evaluate Efield.   Efield_func(x, Efield);   return Efield * n;}// Ionization spatial function.double Zbar_func(const Vector &x){   //double Z0 = 1.0;   return Z0;}// Electron density spatial function.double ne_func(const Vector &x){   //double ne0 = 1.0;   return ne0;}// Electron temperature spatial function.double Te_func(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   double X2 = 0.0;   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);      X2 += pow(X(i), 2);   }      double Te0 = 1.0;   return Te0 * exp(-30.*X2);;}// Thermal velocity spatial function.double vth_func(const Vector &x){   return pow(kB * Te_func(x) / me, 0.5);}// Thermal velocity spatial function.double coulLog_func(const Vector &x){   return 1.0;}// BGK related collision cross section.double rB_func(const Vector &x){   double xi = (Zbar_func(x) + 0.24) / (Zbar_func(x) + 4.2);   return 1.0; //(zeta * Z) / xi / (Z + 2.0 * zeta);}double rBneGamma_therm_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return rB_func(x) * ne_func(x) * Gamma;}double rBneGamma_scat_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return rB_func(x) / zeta * ne_func(x) * Gamma * (Zbar_func(x) + zeta);}// AWBS related collision cross section.double neGammaHalf_therm_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return 0.5 * ne_func(x) * Gamma;}double neGammaHalf_scat_func(const Vector &x){   double Gamma = sigma * coulLog_func(x);   return ne_func(x) * Gamma * (Zbar_func(x) + 0.5);}// Source of particlesdouble Q_BGK_func(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   double X2 = 0.0;   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);      X2 += pow(X(i), 2);   }   // BGK source corresponds to    // fM = ne / 2pi^1.5 / vth^3 * exp(-v^2/2/vt^2).   double fM = ne_func(x) / pow(2.0 * pi, 1.5) / pow(vth_func(x), 3.0)               * exp(-pow(velocity, 2.0) / 2.0 / pow(vth_func(x), 2.0));   return rBneGamma_therm_func(x) * fM;   //return Gamma * fM;   //return Gamma * exp(-30.*X2);}// Source of particlesdouble Q_AWBS_func(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   double X2 = 0.0;   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);      X2 += pow(X(i), 2);   }   // AWBS source corresponds to    // dfMdv = -v / vth^2 * fM   // where fM = ne / 2pi^1.5 / vth^3 * exp(-v^2/2/vt^2).   double fM = ne_func(x) / pow(2.0 * pi, 1.5) / pow(vth_func(x), 3.0)                * exp(-pow(velocity, 2.0) / 2.0 / pow(vth_func(x), 2.0));   double dfMdv = - velocity / pow(vth_func(x), 2.0) * fM;   switch (problem)   {      case 0: return sigma * exp(-30.*X2);      case 1: return 0.0;   }   return 0.0;}/*// Inflow boundary condition (zero for the problems considered in this example)double inflow_function(const Vector &x){   switch (problem)   {      case 0:      case 1:      case 2:      case 3: return 0.0;   }   return 0.0;}*/